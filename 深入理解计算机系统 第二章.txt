习题2-1
a.0x39A7F8 --> 0011 1001 1010 0111 1111 1000
b.1100 1001 0111 1011 --> 0xC97B
c.0xD5E4C --> 1101 0101 1110 0100 1100
d.0010 0110 1110 0111 1011 0101 --> 0x26E7B5

习题2-2
n      2^n 十进制       2^n十六进制
9      512              0x200
19     524288           0x80000
14     16384            0x4000
16     65536            0x10000
17     131072           0x20000
5      32               0x101
7      128              0x80

习题2-3
十进制            二进制               十六进制
0                 0000 0000            0x00
167               1010 0111            0xA7
62                0011 1110            0x3E
188               1011 1100            0xBC
55                0011 0111            0x37
136               1000 1000            0x88
244               1111 0011            0xF3
82                0101 0010            0x52  
172               1010 1100            0xAC
232               1110 0111            0xE7

习题2-4
a.0x503c+0x8 = 0x5045
b.0x503c-0x40 = 0x4FFc
c.0x503c+64 = 0x507c
d.0x50ea-0x503c = 0xae

习题2-5
a.小端法: 21        大端法: 87
b.小端法: 21 43     大端法: 87 65
c.小端法: 21 43 65  大端法: 87 65 43

习题2-6
a. 0x00359141 --> 0000 0000 0011 0101 1001 0001 0100 0001
   0x4A564504 --> 0100 1010 0101 0110 0100 0101 0000 0100
b.00000000001101011001000101000001
             *********************
    01001010010101100100010100000100
21位匹配
c.a串前半部分不匹配 b串左后两位和前端9位不匹配

习题2-7
 61 62 63 64 65 66 00

习题2-8
运算         结果
a            01101001
b            01010101

~a           10010110
~b           10101010

a&b          01000001
a|b          01111101
a^b          00111100

习题2-9
a.黑色 -补-> 白色
  蓝色 -补-> 黄色
  绿色 -补-> 红紫色
  蓝绿色 -补-> 红色
  红色 -补-> 蓝绿色
  红紫色 -补-> 绿色
  黄色 -补-> 蓝色
  白色 -补-> 黑色
b.蓝|绿 = 蓝绿
  黄&蓝绿 = 绿
  红^红紫 = 蓝

习题2-10
步骤    *x     *y
初始    a      b
第一步  a      a^b
第二步  b      a^b
第三步  b      a

习题2-11
a.k+1
b.由于x y指向同一地址 导致*x=*y 则第一步会有 *x = *y = *x ^ *y = 0
所以才会出现0
c.
void inplace_swap(int *x, int *y)
{
     if (x == y) return;
     *y = *x ^ *y;
     *x = *x ^ *y;
     *y = *x ^ *y;
}

习题2-12
a.x & 0xFF  且 可以过滤非选定位 置0非选定位
b.x ^ (~0xFF) 异或 可以取反选定位
c.x | 0xFF 或 可以置1选定位

习题2-13
bis  --- x | m
bic  --- x & (~m)

int bool_or(int x,int y)
{
    int result = bis(x,y);
    return result;
}

int bool_xor(int x,int y)
{
    int result = bis(bic(x,y),bic(y,x));
    return result;
}

习题2-14
x=0x66   y=0x39
表达式       值       表达式       值
x&y        0x20       x&&y       0x01
x|y          0x7F       x||y       0x01
~x|~y      0xDF       !x||!y     0x00
x&!y       0x00       x&&~y      0x01

习题2-15
!(x^y)


习题2-16
x	x<<3	x>>2 逻辑的	 x>>2 算数的
十六进制	二进制	二进制	十六进制	二进制	十六进制	二进制	十六进制
0xC3	1100 0011	0001 1000 	0x18	0011 0000	0x30	1111 0000	0xF0
0x75	0111 0101	1010 1000	0xA8	0001 1101	0x1D	0001 1101	0x1D
0x87	1000 0111	0011 1000	0x38	0010 0001	0x21	1110 0001	0xE1
0x66	0110 0110	0011 0000	0x30	0001 1001	0x19	0001 1001	0x19


习题2-17
                     向量x	B2U4(向量x)	B2T4(向量x)
十六进制	二进制	 	 
0xE	1110	8+4+2=14	-8+4+2=-2
0x0	0000	0	0
0x5	0101	4+1=5	4+1=5
0x8	1000	8	-8
0xD	1101	8+4+1=13	-8+4+1=-3
0xF	1111	8+4+2+1=15	-8+4+2+1=-1


习题2-18
a.0x1b8->0001 1011 1000->8+16+32+128+256=440
b.0x14->0001 0100->16+4=20
c.0xfffffe58->1111 1111 1111 1111 1111 1110 0101 1000->-1-7-32-128-256=--324
d.0xfffffe74->1111 1111 1111 1111 1111 1110 0111 0100->-1-3-8-128-256=-396
e.0x44->0100 0100->64+4=68
f.0xfffffec8->1111 1111 1111 1111 1111 1110 1100 1000->-1-7-16-32=-56
g.0x10->0001 0000->16;
h.0xc->1100->-8+4=-4
I.0xfffffeec->1111 1111 1111 1111 1111 1110 1110 1100->-1-19=-20
j.0x20->0010 0000->32

习题2-19
x	T2U(x)
-8	8
-3	13
-2	14
-1	15
0	0
5	5

习题2-20
-8 < 0   T2U(-8) = -8 + 16 = 8
-3 < 0   T2U(-3) = -3 + 16 = 13
-2 < 0   T2U(-2) = -2 + 16 = 14
-1 < 0   T2U(-1) = -1 + 16 = 15
0 >= 0   T2U(0) = 0
5 >= 0   T2U(5) = 5

习题2-21
2^32 = 4294967296
表达式	类型	求值
-2147483647-1== 2147483648U	无符号	1
-2147483647-1<2147483647	有符号	1
-2147483647-1U<2147483647	无符号	0 ==
-2147483647-1<-2147483647	有符号	1
-2147483647-1U<-2147483647	无符号	1

习题2-22
a.[1011] = -8 + 2+ 1 = -5
b.[11011] = -16 + 8 + 2 + 1 = -5
c.[111011] = -32 +16 + 8 + 2 + 1 = - 5




习题2-23
a.
w	fun1(w)	fun2(w)
0x00000076	0x00000076=118	0x00000076=118
0x87654321	0x00000021=33	0x00000021=33
0x000000c9	0x000000c9=201	0xFFFFFF21= -223
0xedcba987	0x00000087=135	0xFFFFFF87= -111
b.
fun1 将输入参数 高24位置0 再按有符号数解释
fun2 将输入参数 高24位置1 再按有符号数解释

习题2-24
十六进制	无符号	补码
原始值	截断值	原始值	截断值	原始值	截断值
0	0	0	0	0	0
2	2	2	2	2	2
9	1	9	1	-7	1
B	3	11	3	-5	3
F	7	15	7	-1	-1


习题2-25
错误在 length-1， length是无符号数 ，1是有符号数，length-1则会强制默认1也是无符号的，所以得到的结果是无符号的，而无符号数无法表示-1,则得到Umax即最大值，则数组访问溢出报错。
改写：for (i=0;i<length;i++)

习题2-26
a.错误：不论两个字符串长度如何 始终返回1（true）
b.原因：无符号数始终是大于0的
c.改写：int ret = strlen(first) C strlen(second); return ret > 0;

习题2-27
int uadd_ok(unsigned x, unsigned y)
{
	unsigned result = x + y;
	if (result < x) return 0;
	else return 1;
}

习题2-28
x	-u4x
十六进制	十进制	十进制	十六进制
0	0	0	0
5	5	11	B
8	8	8	8
D	13	3	3
F	15	1	1

习题2-29
x	y	x+y	x+t5y	情况
0x10100	0x10001	0x100101	0x00101	1
0x11000	0x11000	0x110000	0x10000	2
0x10111	0x01000	0x11111	0x11111	2
0x00010	0x00101	0x00111	0x00111	3
0x01100	0x00100	0x10000	0x10000	4

习题2-30
int tadd_ok(int x, int y)
{
	int result = x + y;
	if (result < 0 && x >= 0 && y >= 0) return 0;
	else if (result >= 0 && x < 0 && y < 0) return 0;
	else return 1;
}

习题2-31
当x+y溢出的时候，sum-x也会溢出，使其结果依然等于y，所以该公式结果永远是1

习题2-32
当y=Tmin的时候，-y=0-Tmin=Tmax+1溢出，-y依然是Tmin，如果此时x=Tmin，本来x-y=0不溢出，而此时x-y=2Tmin溢出，返回结果出错。

习题2-33
x	-t4x
十六进制	十进制	十进制	十六进制
0 0000	0	0	0000 0
5 0101	5	-5	1011 B
8 1000	-8	-8	1000 8
D 1101	-3	3	0011 3
F 1111	-1	1	0001 1

习题2-34
模式	x	y	x*y	截断的x*y
无符号	100 4	101 5	20 010100	100
补码	100 -4	101 -3	12 001100	100
无符号	010 2	111 7	14 001110	110
补码	010 2	111 -1	-2  111110	110
无符号	110 6	110 6	36 100100	100
补码	110 -2	110 -2	4 000100	100

习题2-38
1 2 3 4 5 8 9 

习题2-39
-（x<<m）

习题2-40
k	移位	加法/减法	x*k
6          0000110	2	1	(x <<2) + (x <<1) 
31        0011111  	1	1	(x <<5) - x
-6         1111010	2	1	(x <<1) C (x <<3) 
55        0110111	2	2	(x<<6)-(x<<3)-x


习题2-45
小数值	二进制	十进制
1/8	0.001	0.125
3/4	0.11	0.75
25/16	1.1001	1.5625
2+11/16	10.1011	2.6875
1+1/8	1.001	1.125
5+7/8	101.111	5.875
3+3/16	11.0011	3.1875


习题2-46
a. 浮点数误差 x=0.099609375
b.0.000390625
c. 1406.25s = 23.4375min
d.假设 雷达每1秒 检测一次   那么最大误差是7.8125m


习题2-51
1. x = 0. 00011001100110011001100 1100    x' =  x = 0.00011001100110011001101
2.x' C 0.1 =  0.00011001100110011001101 -
			 0.000110011001100110011001100 =  0.0000000000000000000000 00100
 = 1 / 2^25
3. 3^2 * 5^5 / 2^18 = 0.107s
4.假设 雷达每1秒 检测一次   那么最大误差是 625 / 2^20 = 0.000596m




习题2-47
位	e	E	2^E	f	M	2^E* M	V	十进制
0 00 00	0	1-1	1	0	0	0	0	0
0 00 01	0	1-1	1	1/4	1/4	1/4	1/4	0.25
0 00 10	0	1-1	1	1/2	1/2	1/2	1/2	0.5
0 00 11	0	1-1	1	3/4	3/4	3/4	3/4	0.75
0 01 00	1	1-1	1	0	1	1	1	1
0 01 01	1	1-1	1	1/4	5/4	5/4	5/4	1.25
0 01 10	1	1-1	1	1/2	3/2	3/2	3/2	1.5
0 01 11	1	1-1	1	3/4	7/4	7/4	7/4	1.75
0 10 00	2	2-1	2	0	1	2	2	2
0 10 01	2	2-1	2	1/4	5/4	10/4	5/2	2.5
0 10 10	2	2-1	2	1/2	3/2	6/2	3	3
0 10 11	2	2-1	2	3/4	7/4	14/4	7/2	3.5
0 1100	3	3-1	4	0	1	4	4	4
0 1101	3	3-1	4	1/4	5/4	20/4	5	5
0 1110	3	3-1	4	1/2	3/2	12/2	6	6
0 1111	3	3-1	4	3/4	7/4	28/4	7	7

习题2-48
3510593   0x00359141 = 1.1 0101 1001 0001 0100 0001 * 2^21
符号位 0 阶码位 10010100 小数位 1010 1100 1000 1010 0000 100

结果 0100 1010 0101 0110 0100 0101 0000 0100 = 0x4A564504


习题2-50
a 10.010 → 10.0 
b 10.011 → 10.1
c 10.110 → 11.0
d 11.001 → 11.0

习题2-52
格式A	格式B
位	值	位	值
011 0000	1	0111 000	1
101 1110	7.5  	1001 111	7.5
010 1001	25/32	0110 100	3/4
110 1111	15.5	1011000	16
000 0001	1/128	0001 000	1/128

